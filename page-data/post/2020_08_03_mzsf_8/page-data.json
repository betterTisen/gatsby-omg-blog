{"componentChunkName":"component---src-templates-post-js","path":"/post/2020_08_03_mzsf_8/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby OMG Blog","post":{"pageviews":true}}},"markdownRemark":{"id":"cb08e138-61fd-5d02-9d47-f4992c4d2ad9","excerpt":"…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d7880f3d5305062adff4660f8f1ff67c/f67cc/1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.12499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAFbsrdSUYP/xAAbEAACAQUAAAAAAAAAAAAAAAABAgMAEBITMf/aAAgBAQABBQIHWsK4x0/Lf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABsQAAEEAwAAAAAAAAAAAAAAAAEAAhAhEjFR/9oACAEBAAY/Asgr2bMMHTP/xAAZEAEBAAMBAAAAAAAAAAAAAAABABEhMUH/2gAIAQEAAT8hy+x4TmSF2yXwDm8nt//aAAwDAQACAAMAAAAQRy//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhQTFRcYH/2gAIAQEAAT8QpUDQvFuJTDcpu2EE9xRuIH03qG8yXs//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/d7880f3d5305062adff4660f8f1ff67c/88218/1.jpg\"\n        srcset=\"/static/d7880f3d5305062adff4660f8f1ff67c/7237a/1.jpg 148w,\n/static/d7880f3d5305062adff4660f8f1ff67c/0cfdf/1.jpg 295w,\n/static/d7880f3d5305062adff4660f8f1ff67c/88218/1.jpg 590w,\n/static/d7880f3d5305062adff4660f8f1ff67c/f67cc/1.jpg 800w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>我们知道数组是一种通用的数据结构，能用来实现栈、队列等很多数据结构。而链表也是一种使用广泛的通用数据结构，它同样也可以用来作为实现栈、队列等数据结构，</p>\n<p><strong>除非需要频繁的通过下标来随机访问各个数据，否则很多使用数组的地方都可以用链表来代替。</strong></p>\n<p>本周我们会进入链表篇的学习，我将和大家一起学习常考的链表算法题型。第一道题，是一道经典的链表考法，同样也是阿里一面的笔试题目，我们一起来学习一下吧。</p>\n<h2 id=\"【动图算法】链表篇：反转链表\">【动图算法】(链表篇)：反转链表</h2>\n<blockquote>\n<p>leetcode 206 题：反转链表<br>\n<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>\n</blockquote>\n<p>实现一个函数，用于反转一个单链表。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">输入<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">2</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">3</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">4</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">5</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token constant\">NULL</span>\n输出<span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">4</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">3</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">2</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token constant\">NULL</span>\n\n<span class=\"token comment\">/**\n * @param {ListNode} head\n * @return {ListNode} head\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">reverseList</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">head</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>进阶：你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</strong></p>\n<h2 id=\"解答过程\">解答过程</h2>\n<p>本题的难点是指针的指向问题，要注意：链表中的next 指向的是下一段内存空间的地址！所以对链表的每一步操作都要小心仔细，防止内存指向修改导致结果错误的问题</p>\n<h3 id=\"迭代法-️\">迭代法 ♻️</h3>\n<p>基础解法，很容易想到。通过一个循环，按部就班的对链表的每项依次进行反转～</p>\n<p><img src=\"/45993bb254be76bc79c5659b96fcca53/2.gif\"></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">reverseList</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">head</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> nxt <span class=\"token operator\">=</span> head\n    <span class=\"token keyword\">let</span> pre <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>nxt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> cc <span class=\"token operator\">=</span> nxt<span class=\"token punctuation\">.</span>next\n        nxt<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> pre\n        pre <span class=\"token operator\">=</span> nxt\n        nxt <span class=\"token operator\">=</span> cc\n        <span class=\"token comment\">// 下面是上面4行代码的简写（es6的解构赋值，简化了多行的赋值代码）</span>\n        <span class=\"token comment\">// [nxt.next, pre, nxt]=[pre, nxt, nxt.next]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> pre\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>首先用一个变量缓存原指针的下一个节点</li>\n<li>然后将原指针的指向反转，赋值给pre指针</li>\n<li>最后将缓存的变量赋值给原指针</li>\n</ul>\n<h3 id=\"递归法1-（尾递归）\">递归法1 🐢（尾递归）</h3>\n<p>由于迭代每一步所做的工作都是重复性的，那么思考一下🤔是否可以找到一个规律，把上面的方法改造成递归呢？</p>\n<p>然后便有了如下解法：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">handleReverse</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">node<span class=\"token punctuation\">,</span>list</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 进行反转</span>\n    <span class=\"token keyword\">let</span> next <span class=\"token operator\">=</span> list<span class=\"token punctuation\">.</span>next \n    <span class=\"token keyword\">let</span> pre <span class=\"token operator\">=</span> list\n    pre<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node\n    <span class=\"token comment\">// 如果链表遍历结束时return pre</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>next<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> pre\n    <span class=\"token comment\">// 如果链表遍历未结束则继续反转链表的下一项</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">handleReverse</span><span class=\"token punctuation\">(</span>pre<span class=\"token punctuation\">,</span>next<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">reverseList</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">head</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>head <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> head\n    <span class=\"token keyword\">return</span> <span class=\"token function\">handleReverse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>head<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里创建了一个<code class=\"language-text\">handleReverse</code>函数，因为原始函数只有一个变量，而只通过一个变量来进行链表反转不太方便，所以对原函数结构进行调整，通过传入<code class=\"language-text\">反转过的节点pre</code>和<code class=\"language-text\">未反转的节点next</code>来对链表结构进行递归操作。</p>\n<h3 id=\"递归法2-\">递归法2 🐢🐢</h3>\n<p>既然尾递归可以实现反转链表，那么接下来就尝试通过递归自身来实现呢？</p>\n<p>于是便有了这种的解法：</p>\n<p><strong>注意：该解法需要对链表的指针定义有一定的认知，但为了方便大家理解，这里也用一张动图来直观的描述一下。但是建议先看代码再看图片！</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">reverseList</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">head</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>head <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> head\n    <span class=\"token keyword\">let</span> next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next\n    <span class=\"token comment\">// 这里的next传入的是地址，而非值</span>\n    <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token function\">reverseList</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 进行反转</span>\n    next<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head\n    head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token keyword\">return</span> res\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>以上所有的操作都是对链表的地址进行的，所以在递归中的链表操作，也会对外层函数存在影响，下面看这张图就会明白啦！</p>\n<p><img src=\"/03b8f73dfaab7a59d0bca1892fb3a6e9/3.gif\" alt=\"由于图片较长，手机上可能会字体模糊，建议在电脑查看～\"></p>\n<h2 id=\"最后\">最后</h2>\n<p>这次题目的三种解法中前面两种都很好理解，主要是第三种解法可能会有些绕，大家可以多熟悉一下～当这道题理解透时对js的变量存储机制应该也就掌握了。毕竟如果笔试时写出这样的解法面试官肯定会觉得：卧槽🐂🍺～</p>","headings":[{"value":"【动图算法】(链表篇)：反转链表","depth":2},{"value":"解答过程","depth":2},{"value":"迭代法 ♻️","depth":3},{"value":"递归法1 🐢（尾递归）","depth":3},{"value":"递归法2 🐢🐢","depth":3},{"value":"最后","depth":2}],"frontmatter":{"title":"【动图算法】(链表篇)：反转链表","date":"August 02, 2020","description":"来自 一个歪卜 公众号文章，欢迎大家在文章下方评论区评论，也可以写出下周题目的解题思路哦～","tags":["javascript","每周算法"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2020_08_03_mzsf_8/","previous":{"fields":{"slug":"/post/2020_07_27_mzsf_7/"},"frontmatter":{"title":"【每周算法】双指针算法各类题型总结"}},"next":{"fields":{"slug":"/post/2020_08_10_mzsf_9/"},"frontmatter":{"title":"【动图算法】(链表篇)：旋转链表"}}}}}