{"componentChunkName":"component---src-templates-post-js","path":"/post/2020_09_14_mzsf_12/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby OMG Blog","post":{"pageviews":true}}},"markdownRemark":{"id":"826d29f0-3a5f-57ed-ad06-907a579134ca","excerpt":"在开始做动态规划的题目前，先说一个小故事，让不知道的同学先了解何为动态规划～ 所以说在之前的计算结果基础上进行二次计算，可以有效的提高计算效率，这就是动态规划！ 接下来就通过一道简单的题目来学习一下动态规划。 【动图算法】（动态规划篇）：斐波那契数 leetcode 509 题：斐波那契数 https…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c0b40b8f6796aed22bb73fdd2aa06137/32fac/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.41025641025641%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABX0lEQVQoz2MQK92AC4lXbBYv34xHAQN2bWUbBfJXGVSv0q1aBWQAuSRoFitZJ1a5Q7rxgFTjAbGq7SAuQc2iUGs3iRevlZz+RK56q3zdLslpj8SL14iXbxIr3SiKQ/NG0eK10iWrxQpXCxetESnZIDP5jsm0SybTr8hOviNSvE64aK1E0SrJ4tVAZUDFKJqBtgnnL9ebcV2x9ZBKwy7l5n2i2QtEkqeIJE0WyVqg3LxfuX6HRschzak3hHOXgV2BqlmkYCVQBVCnbtdh9b6znMFNPLYxQk5J/NHd6v0XdDsPqTfulK/bKZK/QqxsE4afS9YDrRLOWgh0pFjNbteJB/QqV2iULnGZsE+0ZrdI8VrhrAXCyVNxh3blNvHyLcCwlaja5r78kda0m+qTrzktvg8UBwqKV2wBMXBqLlkPZwOjV6Rsi0j5VoH81TBZFAW447l0g0QZMIVtASIgA5caAA33FDg7KuP+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/c0b40b8f6796aed22bb73fdd2aa06137/799d3/1.png\"\n        srcset=\"/static/c0b40b8f6796aed22bb73fdd2aa06137/00d96/1.png 148w,\n/static/c0b40b8f6796aed22bb73fdd2aa06137/0b23c/1.png 295w,\n/static/c0b40b8f6796aed22bb73fdd2aa06137/799d3/1.png 590w,\n/static/c0b40b8f6796aed22bb73fdd2aa06137/32fac/1.png 780w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>在开始做动态规划的题目前，先说一个小故事，让不知道的同学先了解何为动态规划～</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">A <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"1+1+1+1+1+1+1+1 =？\"</span>\nA <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"上面等式的值是多少\"</span>\nB <span class=\"token builtin class-name\">:</span> *计算* <span class=\"token string\">\"8!\"</span>\nA <span class=\"token builtin class-name\">:</span> 在上面等式的左边写上 <span class=\"token string\">\"1+\"</span>\nA <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"此时等式的值为多少\"</span>\nB <span class=\"token builtin class-name\">:</span> *quickly* <span class=\"token string\">\"9!\"</span>\nA <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"你怎么这么快就知道答案了\"</span>\nA <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"只要在8的基础上加1就行了\"</span>\nA <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'\"</span></code></pre></div>\n<p><strong>所以说在之前的计算结果基础上进行二次计算，可以有效的提高计算效率，这就是动态规划！</strong></p>\n<p>接下来就通过一道简单的题目来学习一下动态规划。</p>\n<h2 id=\"【动图算法】（动态规划篇）：斐波那契数\">【动图算法】（动态规划篇）：斐波那契数</h2>\n<blockquote>\n<p>leetcode 509 题：斐波那契数<br>\n<a href=\"https://leetcode-cn.com/problems/fibonacci-number/submissions/\">https://leetcode-cn.com/problems/fibonacci-number/submissions/</a></p>\n</blockquote>\n<p><strong>斐波那契数</strong>，通常用 <code class=\"language-text\">F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>   <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token constant\">N</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> 其中 <span class=\"token constant\">N</span> <span class=\"token operator\">></span> <span class=\"token number\">1.</span>\n🌰\n输入：<span class=\"token number\">4</span>\n输出：<span class=\"token number\">3</span>\n解释：<span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token number\">3.</span></code></pre></div>\n<h2 id=\"解答过程\">解答过程</h2>\n<h3 id=\"递归法-\">递归法 🐢</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>先来分析一下递归算法的执行流程，假如输入5，那么执行的递归树如下：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f3aa67c09ea263ccc728e002f53d9902/983e0/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.65437788018433%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAABYlAAAWJQFJUiTwAAABQ0lEQVQoz41TgY6CMAzl/z9QTVTUAc54Xg5kdKXbypVNjZ5y2gRS1r71vbeRDf+GMUZrfTqdmrp+rmZTME5gsF/HMb5/av4QnPrAD527QDo/oP8AzMzykOeaUhpj4LpnFy7f0+D4Rh78I1EKgw3Tk9OWYs9quczXa0nuq4h2PptVZVGWZQjhxWSZZskbwMZ0jui+ZD2DxaazPWIa8xd8JhZ6Ujq7h3Xw3EbzZJ34Fe1x7NVSDDw2Xb0R50PMxTPwd+DEwZh2sZjrfaUPh77vRfZuu9P6gBYLpfL1SqQCwL6qxA6lVNu22c1hcMEAnDt01Mt2KP4AYJRHRAKz1opPzrmYWu99FmlxS5zuQ0Mjset5vYlEezzA1C47PN+kSbDI20ps8qqqhKTaqU2eF0Uhv8TNjklwkietokokSd7FEG1vJ/8CjhdxNCvIIlsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"2\"\n        src=\"/static/f3aa67c09ea263ccc728e002f53d9902/799d3/2.png\"\n        srcset=\"/static/f3aa67c09ea263ccc728e002f53d9902/00d96/2.png 148w,\n/static/f3aa67c09ea263ccc728e002f53d9902/0b23c/2.png 295w,\n/static/f3aa67c09ea263ccc728e002f53d9902/799d3/2.png 590w,\n/static/f3aa67c09ea263ccc728e002f53d9902/983e0/2.png 868w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>可以看到上面的递归树中的每一个子节点都会执行一次，很多重复的节点被执行，fib(2)被重复执行了3次。所以这一部分显然可以优化一波。</p>\n<p>接下来尝试通过一个数组，将已经执行过的节点进行保存。</p>\n<h3 id=\"数组维护法-\">数组维护法 🔧</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> n\n    <span class=\"token keyword\">const</span> memo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\t<span class=\"token comment\">// 通过memo数组存储需要维护的结果</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> memo<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 对0，1初始化</span>\n    memo<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    memo<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">handleFib</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">else</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">handleFib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">handleFib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">handleFib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里通过创建一个数组对计算结果进行存储。在<code class=\"language-text\">handleFib()</code>中，判断数组中对应的结果是否存在，如果存在，则能够省去一次计算。</p>\n<p>但是，仔细看完这段代码后你会发现，这里依然需要每次对之前结果进行访问，通过多次递归才能得到结果。在输入5后一样需要多次访问<code class=\"language-text\">F(2)</code>,但是我们理应只需要拿一次 <code class=\"language-text\">F(2)</code>，所以便有了接下来的优化。</p>\n<h3 id=\"动态规划-️\">动态规划 ♻️</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> n\n    <span class=\"token keyword\">let</span> memo <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n        <span class=\"token punctuation\">[</span>res<span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>res <span class=\"token operator\">+</span> memo<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> res\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"/5d3c9cec5ecfb2c1880559402a4d86c7/3.gif\"></p>\n<p>从图上可以很清楚的看出，这一方法也是利用数组保存了先计算的值，为后面的调用服务。但是每个值只计算且调用了一次，而前一方法中调用了多次，同时参与循环的只有memo和res两个变量，因此该方法也是大大减少了空间复杂度。</p>\n<h2 id=\"最后\">最后</h2>\n<p>这里通过了这一道简单且基础的题目和大家一起初步认识了一下动态规划，在未来的几周内我们会继续学习动态规划类型的题目。</p>","headings":[{"value":"【动图算法】（动态规划篇）：斐波那契数","depth":2},{"value":"解答过程","depth":2},{"value":"递归法 🐢","depth":3},{"value":"数组维护法 🔧","depth":3},{"value":"动态规划 ♻️","depth":3},{"value":"最后","depth":2}],"frontmatter":{"title":"【动图算法】（动态规划篇）：斐波那契数","date":"September 14, 2020","description":"来自 一个歪卜 公众号文章，欢迎大家在文章下方评论区评论，也可以写出下周题目的解题思路哦～","tags":["javascript","每周算法"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2020_09_14_mzsf_12/","previous":{"fields":{"slug":"/post/2020_09_08_chrome_extention/"},"frontmatter":{"title":"React + TypeScript 写一个Chrome书签共享平台"}},"next":{"fields":{"slug":"/post/2020_09_21_mzsf_13/"},"frontmatter":{"title":"【动图算法】（动态规划篇）：最长回文子串"}}}}}